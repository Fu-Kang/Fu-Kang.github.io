<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法系列：树状数组</title>
      <link href="/2021/10/11/algorithm/article-3/"/>
      <url>/2021/10/11/algorithm/article-3/</url>
      
        <content type="html"><![CDATA[<h1 id="算法系列：树状数组"><a href="#算法系列：树状数组" class="headerlink" title="算法系列：树状数组"></a>算法系列：树状数组</h1><p>树状数组是一个查询和修改复杂度都为 $log(n)$ 的数据结构。用二进制的位数代表数组的索引值，主要用于数组的单点修改和区间求和。</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20211011131548.png" alt="树状数组图解"></p><p>更新过程是每次加了个二进制的低位1$ (101+1 -&gt;110, 110 + 10 -&gt; 1000, 1000 + 1000 -&gt; 10000)$</p><p>查询过程每次就是去掉了二进制中的低位1$ (1111 - 1 -&gt; 1110, 1110 - 10 -&gt; 1100, 1100 - 100 -&gt; 1000)$</p><p>所以需要一个取出x的最低位1的函数$lowbit(x)$。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int lowbit(x){return x&amp;(-x);}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体更新和查询的过程，可以参考后面例题的代码，这里就不放了哈。</p><h2 id="1-POJ-3067-Japan"><a href="#1-POJ-3067-Japan" class="headerlink" title="1. POJ 3067 Japan"></a>1. POJ 3067 Japan</h2><p>题意：日本计划在东边的城市和西边的城市中建路，东边的点从 $1…..n$，西边的点从 $1…..m$, 求这些点连起来后有多少交叉。</p><p>这个题其实是求逆序对的个数，本质上还是考察树状数组的应用。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1005;int tr[N];int n, m, k, res;struct node{    int l, r;}num[N];bool cmp(node a, node b) {    if(a.l == b.l) return a.r &lt; b.r;    return a.l &lt; b.l;}int lowbit(int x) {    return x &amp; (-x);}void update(int x, int a) {    for(int i = x; i &lt;= m; i += lowbit(i)) {        tr[i] += a;    }}int getsum(int x) {    int sum = 0;    for(int i = x; i; i -= lowbit(i)) {        sum += tr[i];    }    return sum;}int main(){    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);    int T;    cin &gt;&gt; T;    while(T--) {        res = 0;        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;        for(int i = 0; i &lt; k; i++) {            cin &gt;&gt; num[i].l &gt;&gt; num[i].r;        }        // 先根据左边的坐标进行排序        sort(num, num + k, cmp);        for(int i = 0; i &lt; k; i++) {            // 算出当前线跟之前线的焦点个数，不断累加            res += getsum(m) - getsum(num[i].r);            // 在该点的右边坐标+1            update(num[i].r, 1);        }        cout &lt;&lt; res &lt;&lt; endl;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-PAT-A1057-Stack"><a href="#2-PAT-A1057-Stack" class="headerlink" title="2.PAT A1057 Stack"></a>2.PAT A1057 Stack</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805417945710592">题目链接</a></p><p>这个题的关键问题是求一些给定数的中位数，由于数据范围较大，直接暴力的话，肯定会超时，所以我们才有树状数组，根据查询前缀和的方式 + 二分查找来优化此题。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;const int N = 100005;int tree[N];int n;stack&lt;int&gt; s;int lowbit(int x) {    return x &amp; (-x);}void update(int x, int d) {    for(int i = x; i &lt; N; i += lowbit(i)) {        tree[i] += d;    }}int getsum(int x) {    int sum = 0;    for(int i = x; i; i -= lowbit(i)) {        sum += tree[i];    }    return sum;}int PeekMedian() {    int len = s.size();    int target = len % 2 == 0 ? len / 2 : (len + 1) / 2;    int l = 1, r = N;    // 整数二分查找模版    while(l &lt; r) {        int mid = l + r &gt;&gt; 1;        if(getsum(mid) &gt;= target)  r = mid;        else l = mid + 1;    }    return l;}int main(){    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i++) {        string str;        cin &gt;&gt; str;        if(str == "Push") {            int t;            cin &gt;&gt; t;            s.push(t);            // 更新该位置的值为1            update(t, 1);        }                                   else if(str == "Pop") {            if(s.size() == 0) {                cout &lt;&lt; "Invalid" &lt;&lt; endl;            } else {                cout &lt;&lt; s.top() &lt;&lt; endl;                // 恢复该位置的值为0                update(s.top(), -1);                s.pop();            }        }        else if(str == "PeekMedian") {            if(s.size() == 0) {                cout &lt;&lt; "Invalid" &lt;&lt; endl;            } else {                cout &lt;&lt; PeekMedian() &lt;&lt; endl;            }        }    }       return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法系列：单调栈 单调队列</title>
      <link href="/2021/10/11/algorithm/article-2/"/>
      <url>/2021/10/11/algorithm/article-2/</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>首先，单调栈本身也属于栈，属于一个 “先进后出” 的数据结构。单调栈的话，就是需要栈内元素满足单调性的数据结构，可以是单调递增的，也可以是单调递减的。</p><p>对于数组 $[3,1,4,5,2,7]$ 为例，单调递增栈的过程如下：</p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20211011095736.gif" alt="单调栈" style="zoom:80%;"><ol><li><strong>acwing 131 直方图中最大矩形</strong></li></ol><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20211011100602.png" style="zoom:80%;"><p>​        这道题的思路其实并不简单，我们要维护一个单调递增的栈。我们求解的过程是：遍历每个长方形的高，如果当前的遍历高度大于栈顶的高度，那就直接入栈。如果小于栈顶的高度，然后就不断的出栈，直到当前遍历高度大于栈顶的高度或者栈已经空了，在每次出栈的过程中，都会计算当前构成的矩形面积的值，并不断的更新最大值。</p><p>​       注意：这道题还需要存储每个高度对应的矩形的高度，所以用数组模拟栈比较方便操作，就不在使用STL中的stack数据结构。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1e5 + 1000; typedef long long ll; int n, cnt; ll ans; ll a[maxn], s[maxn], w[maxn]; int main() {    while (scanf("%d", &amp;n) &amp;&amp; n != 0) {         a[n + 1] = 0;         cnt = 0;         ans = 0;        // 用数组s模拟栈的情况         memset(s, 0, sizeof(s));         memset(w, 0, sizeof(w));         for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i];         // 这里n + 1的原因是为了让最后一个入栈的元素能够计算        for (int i = 1; i &lt;= n + 1; ++i) {            if (a[i] &gt; s[cnt]) {                s[++cnt] = a[i];                 w[cnt] = 1;             } else {                int width = 0;                 while (s[cnt] &gt; a[i]) {                    // 不断更新该状态下对应的矩形面积                    width += w[cnt];                     ans = max(ans, (ll) width * s[cnt]);                     cnt--;                 }                s[++cnt] = a[i];                 w[cnt] = width + 1;             }        }        printf("%lld\n", ans);     }    return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>LeetCode 503 下一个更大元素</strong></li></ol><p>​        题目要求：给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。 </p><p>​       把两个nums数组拼接在一起，使用单调栈计算出每一个元素的下一个最大值，最后再把结果集即result数组resize到原数组大小就可以了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 版本一class Solution {public:    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) {        // 拼接一个新的nums        vector&lt;int&gt; nums1(nums.begin(), nums.end());        nums.insert(nums.end(), nums1.begin(), nums1.end());        // 用新的nums大小来初始化result        vector&lt;int&gt; result(nums.size(), -1);        if (nums.size() == 0) return result;        // 开始单调栈        stack&lt;int&gt; st;        for (int i = 0; i &lt; nums.size(); i++) {            while (!st.empty() &amp;&amp; nums[i] &gt; nums[st.top()]) {                result[st.top()] = nums[i];                st.pop();            }            st.push(i);        }        // 最后再把结果集即result数组resize到原数组大小        result.resize(nums.size() / 2);        return result;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列与单调栈相似，他们的区别在于单调栈只能从一端进行元素的添加和删除，而单调队列可以维护数组两端元素的添加和删除。</p><p>c++ STL中有一个数据结构 $deque$,可以实现双端队列的效果。即可以在队列的两端进行元素的添加和删除，用来维护单调队列比较方便。（当然也可以直接通过数组进行维护）。</p><p>关于单调队列，最经典的就是滑动窗口模型。</p><ol><li><strong>acwing 154 滑动窗口</strong></li></ol><p>​        题目：给定一个大小为 $n &lt;= 10^6$ 的数组。有一个大小为 $k$ 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 $k$ 个数字。你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1005;int a[N];deque&lt;int&gt; q;int main(){    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++) {        cin &gt;&gt; a[i];    }    // 单调队列维护窗口最小值    for(int i = 1; i &lt;= n; i++) {        // 如果当前队列尾部的值大于当前遍历的值，就不断的弹出尾部的值        while(!q.empty() &amp;&amp; a[q.back()] &gt;= a[i]) {            q.pop_back();        }        // 如果当前队列头部的索引已经超过了滑动窗口的限制，弹出头部的值        while(q.front() &lt;= i - m) {            q.pop_front();        }        q.push_back(i);        // 输出每个窗口对应的最小值        if(i &gt;= m) cout &lt;&lt; a[q.front()] &lt;&lt; " ";     }    cout &lt;&lt; "\n";    q.clear();    for(int i = 1; i &lt;= n; i++) {        while(!q.empty() &amp;&amp; a[q.back()] &lt;= a[i]) {            q.pop_back();        }        while(q.front() &lt;= i - m) {            q.pop_front();        }        q.push_back(i);        if(i &gt;= m) cout &lt;&lt; a[q.front()] &lt;&lt; " ";     }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>acwing 135 最大子序和</strong></li></ol><p>题目：输入一个长度为 $n$ 的整数序列，从中找出一段长度不超过 $m$ 的连续子序列，使得子序列中所有数的和最大。</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20211011121856.png" alt="最大子序和题解"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1005;int a[N], sum[N];deque&lt;int&gt; q;int res;// 单调队列优化算法，算法复杂度为o(n)int main(){    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++) {        cin &gt;&gt; a[i];        sum[i] = sum[i - 1] + a[i];    }    q.push_back(0);    for(int i = 1; i &lt;= n; i++) {        // 如果子序列的长度超过了m, 弹出队列头部的值        while(!q.empty() &amp;&amp; q.front() &lt; i - m) {            q.pop_front();        }        res = max(res, sum[i] - sum[q.front()]);        // 如果当前遍历的值的前缀和小于队列尾部的前缀和，弹出尾部的值        // 原因是区间和是s[R] - s[L],所以s[L]肯定要越小越好。        while(!q.empty() &amp;&amp; sum[q.back()] &gt;= sum[i]) {            q.pop_back();        }        q.push_back(i);    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 算法 </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树刷题总结</title>
      <link href="/2021/08/20/algorithm/article-1/"/>
      <url>/2021/08/20/algorithm/article-1/</url>
      
        <content type="html"><![CDATA[<p>最近在刷PAT甲级，发现在PAT考试中涉及的两种难度较高的大题，基本都是二叉树和图论的范畴，由此可见树论这块的重要性。在今年蓝桥杯比赛中，也由于平时疏忽了二叉树这块的学习，所以当时有一个15分的二叉树大题，虽然难度不高，但是我却没有写出来，所以就先来总结一下二叉树的有关内容吧。</p><p>其实我认为二叉树的应用其实就是<strong>DFS</strong>的应用，所以要熟练掌握DFS算法，才能够更好地理解二叉树的题目。</p><p>对于二叉树的存储，我一般是采用结构体进行存储比较方便, 例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct node {    int left, right;} tree[100005];  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果涉及的题目不是二叉树，而是树的话，那我们可以采用：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct node {    double data;    vector&lt;int&gt; child;} tree[100005];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>先从一道简单的题目开始：</p><h2 id="1-二叉树深度"><a href="#1-二叉树深度" class="headerlink" title="1.二叉树深度"></a>1.二叉树深度</h2><p>题目链接： <a href="https://www.luogu.com.cn/problem/P4913">洛谷 P4913</a></p><p>题目描述：</p><blockquote><p>给出每个节点的两个儿子节点，建立一棵二叉树（根节点为 1），如果是叶子节点，则输入<code>0 0</code>。建好树后希望知道这棵二叉树的深度。二叉树的<strong>深度</strong>是指从根节点到叶子结点时，最多经过了几层。</p><p>最多有 10^6 个结点。</p></blockquote><p>题解：涉及到树的深度，我们首先想到DFS进行深搜，题目已经给定了根节点，所以在DFS的过程中，遇到叶子节点的话，不断的更新深度的最大值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;struct node {    int left, right;}tree[100005];  int n, res;void dfs(int root, int len) {    if(root == 0) {   // 判断是否为叶子节点        res = max(res, len - 1);        return;    }    dfs(tree[root].left, len + 1);    dfs(tree[root].right, len + 1);}int main(){    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i++) {        cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right;     }    dfs(1, 1);    cout &lt;&lt; res &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们可以看一道复杂一些的二叉树的应用题</p><h2 id="2-Infix-Expression"><a href="#2-Infix-Expression" class="headerlink" title="2.Infix Expression"></a>2.Infix Expression</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312">Infix Expression</a></p><p>题解：这个题我们需要根据每个节点的字符、左右节点的值，来求出二叉树代表的表达式。其实观察输出样例，我们发现它的结果就是二叉树的先序遍历，不过我们需要特殊处理（）字符。这个题目，我们首先需要根据输入数据得到对应的根节点，然后进行DFS搜索，通过判断是否为根节点，来考虑是否添加括号。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;#define ll long longstruct node {    string val;    int left, right;}v[25];int vis[25];int root;string dfs(int idx) {    if(idx == -1) return "";    // 根据实际情况，我们发现只要右节点不为0的话，那么就可以继续遍历，例如题目中的-d    if(v[idx].right != -1) {        v[idx].val = dfs(v[idx].left) + v[idx].val + dfs(v[idx].right);        // 如果非叶子节点不是根节点，那么需要加括号        if(idx != root) {            v[idx].val = '(' + v[idx].val + ')';        }    }    return v[idx].val;}int main(){    int n;    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i++) {        cin &gt;&gt; v[i].val &gt;&gt; v[i].left &gt;&gt; v[i].right;        if(v[i].left != -1)  vis[v[i].left] = 1;        if(v[i].right != -1) vis[v[i].right] = 1;    }    // 找出根节点    for(int i = 1; i &lt;= n; i++) {        if(!vis[i]) {            root = i;            break;        }    }    cout &lt;&lt; root &lt;&lt; endl;    cout &lt;&lt; dfs(root) &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Tree-Traversals-Again"><a href="#3-Tree-Traversals-Again" class="headerlink" title="3.Tree Traversals Again"></a>3.Tree Traversals Again</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024">Tree Traversals Again</a></p><p>题解：栈实现的是二叉树的中序遍历（左根右），而每次push入值的顺序是二叉树的前序遍历（根左右），所以该题可以用二叉树前序和中序转后序的方法做。root为当前子树的根结点在前序pre中的下标，start和end为当前子树的最左边和最右边的结点在中序in中的下标。用i找到当前子树的根结点root在中序中的下标，然后左边和右边就分别为当前根结点root的左子树和右子树。用递归就可以实现。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;#define ll long longconst int MAXN = 35;int n, m, cnt, root;// 分别代表二叉树的前序，中序和后序遍历vector&lt;int&gt; pre, in, post;stack&lt;int&gt; s;// root代表前序遍历对应的根节点索引，start，end代表中序遍历该根节点下的元素索引void postorder(int root, int start, int end) {    // 剪枝    if(start &gt; end) {        return;    }    int i = start;    // 找到中序遍历对应的根节点的位置    while(i &lt; end &amp;&amp; in[i] != pre[root]) i++;    // 左边的根节点是中心根节点索引值+1    postorder(root + 1, start, i - 1);    // 右边的根节点是中心根节点索引值+左边元素的个数i - start + 1    postorder(root + i - start + 1, i + 1, end);    // 后序遍历的顺序，先左，在右，最后根节点加入    post.push_back(pre[root]);}int main(){    // freopen("in.txt", "r", stdin);    scanf("%d", &amp;n);    for(int i = 1; i &lt;= 2 * n; i++) {        char str[5];        scanf("%s", str);        if(strlen(str) == 4) {            int num;            scanf("%d", &amp;num);            // 入栈的顺序是二叉树前序遍历的过程            pre.push_back(num);            s.push(num);        } else {            // 出栈的顺序是二叉树中序遍历的过程            in.push_back(s.top());            s.pop();        }    }    // 递归遍历    postorder(0, 0, n - 1);    printf("%d", post[0]);    for(int i = 1; i &lt; n; i++) {        printf(" %d", post[i]);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-Invert-a-Binary-Tree"><a href="#4-Invert-a-Binary-Tree" class="headerlink" title="4.Invert a Binary Tree"></a>4.Invert a Binary Tree</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805365537882112">Invert a Binary Tree</a></p><p>题解：这个题给定了每个点的左右节点的值，然后求得其翻转二叉树的中序遍历和层序遍历，其实本质是一样的，翻转以后，我们中序遍历的顺序变成了右—中—左，层序遍历在每层的遍历顺序改为从右到左，所以我们在结构体的里面，添加了level和idx，代表了节点所在的层数和索引。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;#define ll long longconst int MAXN = 105;int isroot[MAXN];int n, root;// l,r代表左右节点，level代表层数，idx代表索引值struct node{    int id, l, r, level, idx;} tree[MAXN];// in,ceng代表中序，层序遍历vector&lt;node&gt; in, ceng;// 层序遍历，需要按照层数和索引值进行排序，需要cmp进行自定义排序bool cmp(node a, node b){    if (a.level != b.level)        return a.level &lt; b.level;    return a.idx &gt; b.idx;}// root是DFS对应的根节点，level，idx为层数和索引值void dfs(int root, int level, int idx){    if (tree[root].r != -1)    {        // 右边进行遍历，由于idx初始值为0，所以右孩子是idx * 2 + 2        dfs(tree[root].r, idx * 2 + 2, level + 1);    }    // 根节点进入数组    in.push_back({root, 0, 0, idx, level});    if (tree[root].l != -1)    {        // 左边进行遍历，由于idx初始值为0，所以右孩子是idx * 2 + 1        dfs(tree[root].l, idx * 2 + 1, level + 1);    }}int main(){    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    {        string lchild, rchild;        cin &gt;&gt; lchild &gt;&gt; rchild;        if (lchild == "-")        {            tree[i].l = -1;        }        else        {            // stoi函数，讲string转换为int            tree[i].l = stoi(lchild);            isroot[stoi(lchild)] = 1;        }        if (rchild == "-")        {            tree[i].r = -1;        }        else        {            tree[i].r = stoi(rchild);            isroot[stoi(rchild)] = 1;        }    }    // root是根节点    for (int i = 0; i &lt; n; i++)    {        if (!isroot[i])        {            root = i;            break;        }    }    dfs(root, 0, 0);    ceng = in;    // 自定义排序    sort(ceng.begin(), ceng.end(), cmp);    cout &lt;&lt; ceng[0].id;    for (int i = 1; i &lt; ceng.size(); i++)    {        cout &lt;&lt; " " &lt;&lt; ceng[i].id;    }    cout &lt;&lt; endl;    cout &lt;&lt; in[0].id;    for (int i = 1; i &lt; in.size(); i++)    {        cout &lt;&lt; " " &lt;&lt; in[i].id;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>今日份的总结就先到这里了啊，多多支持我的博客！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 算法 </tag>
            
            <tag> PAT甲级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora + picgo + gitee实现图床</title>
      <link href="/2021/08/19/configuration/article-1/"/>
      <url>/2021/08/19/configuration/article-1/</url>
      
        <content type="html"><![CDATA[<h2 id="gitee操作"><a href="#gitee操作" class="headerlink" title="gitee操作"></a>gitee操作</h2><p>登录gitee账号以后，点击新建仓库：</p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819225902.png" alt="image-20210819220159065"><p>仓库建好以后，我们点击设置，设置自己的个人token(也就是私人令牌)，新建以后，会自动生成了一段个人token的号码，一定要记清楚，后面配置的时候会需要。</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819220602.png" alt="image-20210819220601248"></p><h2 id="picgo操作"><a href="#picgo操作" class="headerlink" title="picgo操作"></a>picgo操作</h2><p> 官网下载地址：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p> 版本要求：2.2.0 及以上，我用的是2.2.2</p><p> 下载成功后，打开picgo，会出现如下的界面：</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819220934.png" alt="image-20210819220933193"></p><p>我们首先点击插件设置，搜索gitee，然后下载gitee-uploader插件，等待下载成功后，在图床设置里面会有对应的gitee选项。</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819221246.png" alt="image-20210819221244914"></p><p>这里的repo，我们可以打开刚才新建的仓库，然后查看地址栏，会发现对应的网址（<strong>记住去掉对应的码云域名才行</strong>）</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819221459.png" alt="image-20210819221457888"></p><h2 id="typora操作"><a href="#typora操作" class="headerlink" title="typora操作"></a>typora操作</h2><p>版本要求：0.9.84版本及以上</p><p>打开typora，点击文件 -&gt; 偏好设置，选择图像，上传服务选择PicGo(app)，路径选择picgo下载的路径。</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819224805.png" alt="image-20210819224549748"></p><p>然后，我们点击验证图片上传选项，进行最后的验证。如果返回true，说明图床配置成功！</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819224851.png" alt="image-20210819224849280"></p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>如果最后验证阶段的时候，程序运行结果返回的是false，那么可能会有以下情况：</p><ol><li>picgo配置的路径是否与仓库路径保持一致</li><li>确认下载的插件是否为gitee-uploader</li><li>在picgo设置里面，把时间戳重命名设置开</li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab基本语法</title>
      <link href="/2021/08/18/modeling/article-1/"/>
      <url>/2021/08/18/modeling/article-1/</url>
      
        <content type="html"><![CDATA[<h2 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h2><p>(1) 在每一行的语句后面加上分号(一定要是英文的哦;中文的长这个样子；)表示不显示运行结果</p><p>例如：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">% 表示不显示运行结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(2) 多行注释: 选中要注释的若干语句, 快捷键Ctrl+R</p><p>(3) 取消注释: 选中要取消注释的语句,快捷键Ctrl+T</p><p>(4) 用于起到初始化作用的代码语句：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">clear<span class="token punctuation">;</span>clc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h2><p>(1) disp函数</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'我是kangkang'</span><span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token function">disp</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(2) 字符串的合并(两种)</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token comment">% （1）strcat(str1,str2……,strn) </span><span class="token function">strcat</span><span class="token punctuation">(</span><span class="token string">'字符串1'</span><span class="token punctuation">,</span><span class="token string">'字符串2'</span><span class="token punctuation">)</span> <span class="token comment">% （2）[str 1,str 2，……, str n]或[str1  str2  ……  strn]</span><span class="token punctuation">[</span><span class="token string">'字符串1'</span>  <span class="token string">'字符串2'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>(3) 数字转化为字符串</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">c <span class="token operator">=</span> <span class="token number">100</span><span class="token function">num2str</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token function">disp</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'c的取值为'</span> <span class="token function">num2str</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(4) 输入函数</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token string">'请输入A：'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h2><p>（1）如果是向量（无论是行向量还是列向量），都是直接求和。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">E <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment">% 行向量</span><span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span>E <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment">% 列向量</span><span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（2）如果是矩阵，则需要根据行和列的方向作区分。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">E <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>a <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span>       <span class="token comment">%  默认按列求和(得到一个行向量）</span>a <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token comment">%  按列求和(得到一个行向量）</span>a <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>     <span class="token comment">%  按行求和(得到一个列向量）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（3）对整个矩阵进行求和</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span><span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token function">E</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="取矩阵元素"><a href="#取矩阵元素" class="headerlink" title="取矩阵元素"></a>取矩阵元素</h2><p>（1）取指定行和列的一个元素（输出的是一个值）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">1</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span> <span class="token number">1</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span> <span class="token number">3</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">% 取第二行第一列的元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（2）取指定的某一行 / 列 的全部元素（输出的是一个行向量）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>   <span class="token comment">% 取第二行的所有元素</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment">% 取第一列的所有元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（3）取指定的某些行的全部元素（输出的是一个矩阵）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>      <span class="token comment">% 只取第二行和第五行（一共2行）</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>        <span class="token comment">% 取第二行到第五行（一共4行）</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">:</span><span class="token keyword">end</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>      <span class="token comment">% 取第二行到最后一行</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>      <span class="token comment">% 取第二行和第四行 （从2开始，每次递增2个单位，到5结束）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="size函数"><a href="#size函数" class="headerlink" title="size函数"></a>size函数</h2><p>（1）对于向量来说，返回的是元素的个数</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（2）size(A)函数是用来求矩阵A的大小的,它返回一个行向量，第一个元素是矩阵的行数，第二个元素是矩阵的列数</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>r <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">%  返回行数</span>c <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">%  返回列数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="repmat函数"><a href="#repmat函数" class="headerlink" title="repmat函数"></a>repmat函数</h2><p>B = repmat(A,m,n)： 将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>B <span class="token operator">=</span> <span class="token function">repmat</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>B <span class="token operator">=</span> <span class="token function">repmat</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h2><p>（1）MATLAB在矩阵的运算中， * 号和  / 号代表矩阵之间的乘法与除法(A / B = A * inv(B))</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>A <span class="token operator">*</span> B<span class="token function">inv</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>  <span class="token comment">% 求B的逆矩阵</span>B <span class="token operator">*</span> <span class="token function">inv</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>A <span class="token operator">*</span> <span class="token function">inv</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>A <span class="token operator">/</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）两个形状相同的矩阵对应元素之间的乘除法需要使用“ .* ”和“ ./ ”</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>A <span class="token operator">.*</span> BA <span class="token operator">./</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（3）每个元素同时和常数相乘或相除操作都可以使用</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>A <span class="token operator">*</span> <span class="token number">2</span>A <span class="token operator">.*</span> <span class="token number">2</span>A <span class="token operator">/</span> <span class="token number">2</span> A <span class="token operator">./</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）每个元素同时乘方时只能用 .^</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>A <span class="token operator">.^</span> <span class="token number">2</span>    <span class="token comment">% 表示对每个元素平方</span>A <span class="token operator">^</span> <span class="token number">2</span>     <span class="token comment">% 代表的是 A * A</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a>find函数</h2><p>find函数，它可以用来返回向量或者矩阵中不为0的元素的位置索引。</p><p>（1）对于向量来说，直接返回索引值。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">0</span> <span class="token number">4</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">8</span> <span class="token number">6</span><span class="token punctuation">]</span>ind <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>ind <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment">% 其有多种用法，比如返回前2个不为0的元素的位置：</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）对于矩阵来说，因为在Matlab在存储矩阵时，是一列一列存储的。所以我们要想返回行列值的话，需要：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token number">4</span> <span class="token number">0</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>Matlab的判断语句，if所在的行不需要冒号，语句的最后一定要以end结尾 ；中间的语句要注意缩进。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a <span class="token operator">=</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token string">'请输入考试分数:'</span><span class="token punctuation">)</span><span class="token keyword">if</span> a <span class="token operator">&gt;=</span> <span class="token number">85</span>      <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'成绩优秀'</span><span class="token punctuation">)</span><span class="token keyword">elseif</span> a <span class="token operator">&gt;=</span> <span class="token number">60</span>     <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'成绩合格'</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'成绩挂科'</span><span class="token punctuation">)</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme主题介绍</title>
      <link href="/2021/08/18/hello-world/"/>
      <url>/2021/08/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>‌今天学习了hexo本地创建博客</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
