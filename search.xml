<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树刷题总结（一）</title>
      <link href="/2021/08/20/algorithm/article-1/"/>
      <url>/2021/08/20/algorithm/article-1/</url>
      
        <content type="html"><![CDATA[<p>最近在刷PAT甲级，发现在PAT考试中涉及的两种难度较高的大题，基本都是二叉树和图论的范畴，由此可见树论这块的重要性。在今年蓝桥杯比赛中，也由于平时疏忽了二叉树这块的学习，所以当时有一个15分的二叉树大题，虽然难度不高，但是我却没有写出来，所以就先来总结一下二叉树的有关内容吧。</p><p>其实我认为二叉树的应用其实就是<strong>DFS</strong>的应用，所以要熟练掌握DFS算法，才能够更好地理解二叉树的题目。</p><p>对于二叉树的存储，我一般是采用结构体进行存储比较方便, 例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct node {    int left, right;} tree[100005];  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果涉及的题目不是二叉树，而是树的话，那我们可以采用：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct node {    double data;    vector&lt;int&gt; child;} tree[100005];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>先从一道简单的题目开始：</p><h2 id="1-二叉树深度"><a href="#1-二叉树深度" class="headerlink" title="1.二叉树深度"></a>1.二叉树深度</h2><p>题目链接： <a href="https://www.luogu.com.cn/problem/P4913">洛谷 P4913</a></p><p>题目描述：</p><blockquote><p>给出每个节点的两个儿子节点，建立一棵二叉树（根节点为 1），如果是叶子节点，则输入<code>0 0</code>。建好树后希望知道这棵二叉树的深度。二叉树的<strong>深度</strong>是指从根节点到叶子结点时，最多经过了几层。</p><p>最多有 10^6 个结点。</p></blockquote><p>题解：涉及到树的深度，我们首先想到DFS进行深搜，题目已经给定了根节点，所以在DFS的过程中，遇到叶子节点的话，不断的更新深度的最大值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;struct node {    int left, right;}tree[100005];  int n, res;void dfs(int root, int len) {    if(root == 0) {   // 判断是否为叶子节点        res = max(res, len - 1);        return;    }    dfs(tree[root].left, len + 1);    dfs(tree[root].right, len + 1);}int main(){    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i++) {        cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right;     }    dfs(1, 1);    cout &lt;&lt; res &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们可以看一道复杂一些的二叉树的应用题</p><h2 id="2-Infix-Expression"><a href="#2-Infix-Expression" class="headerlink" title="2.Infix Expression"></a>2.Infix Expression</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312">Infix Expression</a></p><p>题解：这个题我们需要根据每个节点的字符、左右节点的值，来求出二叉树代表的表达式。其实观察输出样例，我们发现它的结果就是二叉树的先序遍历，不过我们需要特殊处理（）字符。这个题目，我们首先需要根据输入数据得到对应的根节点，然后进行DFS搜索，通过判断是否为根节点，来考虑是否添加括号。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;#define ll long longstruct node {    string val;    int left, right;}v[25];int vis[25];int root;string dfs(int idx) {    if(idx == -1) return "";    // 根据实际情况，我们发现只要右节点不为0的话，那么就可以继续遍历，例如题目中的-d    if(v[idx].right != -1) {        v[idx].val = dfs(v[idx].left) + v[idx].val + dfs(v[idx].right);        // 如果非叶子节点不是根节点，那么需要加括号        if(idx != root) {            v[idx].val = '(' + v[idx].val + ')';        }    }    return v[idx].val;}int main(){    int n;    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i++) {        cin &gt;&gt; v[i].val &gt;&gt; v[i].left &gt;&gt; v[i].right;        if(v[i].left != -1)  vis[v[i].left] = 1;        if(v[i].right != -1) vis[v[i].right] = 1;    }    // 找出根节点    for(int i = 1; i &lt;= n; i++) {        if(!vis[i]) {            root = i;            break;        }    }    cout &lt;&lt; root &lt;&lt; endl;    cout &lt;&lt; dfs(root) &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Tree-Traversals-Again"><a href="#3-Tree-Traversals-Again" class="headerlink" title="3.Tree Traversals Again"></a>3.Tree Traversals Again</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024">Tree Traversals Again</a></p><p>题解：栈实现的是二叉树的中序遍历（左根右），而每次push入值的顺序是二叉树的前序遍历（根左右），所以该题可以用二叉树前序和中序转后序的方法做。root为当前子树的根结点在前序pre中的下标，start和end为当前子树的最左边和最右边的结点在中序in中的下标。用i找到当前子树的根结点root在中序中的下标，然后左边和右边就分别为当前根结点root的左子树和右子树。用递归就可以实现。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;#define ll long longconst int MAXN = 35;int n, m, cnt, root;// 分别代表二叉树的前序，中序和后序遍历vector&lt;int&gt; pre, in, post;stack&lt;int&gt; s;// root代表前序遍历对应的根节点索引，start，end代表中序遍历该根节点下的元素索引void postorder(int root, int start, int end) {    // 剪枝    if(start &gt; end) {        return;    }    int i = start;    // 找到中序遍历对应的根节点的位置    while(i &lt; end &amp;&amp; in[i] != pre[root]) i++;    // 左边的根节点是中心根节点索引值+1    postorder(root + 1, start, i - 1);    // 右边的根节点是中心根节点索引值+左边元素的个数i - start + 1    postorder(root + i - start + 1, i + 1, end);    // 后序遍历的顺序，先左，在右，最后根节点加入    post.push_back(pre[root]);}int main(){    // freopen("in.txt", "r", stdin);    scanf("%d", &amp;n);    for(int i = 1; i &lt;= 2 * n; i++) {        char str[5];        scanf("%s", str);        if(strlen(str) == 4) {            int num;            scanf("%d", &amp;num);            // 入栈的顺序是二叉树前序遍历的过程            pre.push_back(num);            s.push(num);        } else {            // 出栈的顺序是二叉树中序遍历的过程            in.push_back(s.top());            s.pop();        }    }    // 递归遍历    postorder(0, 0, n - 1);    printf("%d", post[0]);    for(int i = 1; i &lt; n; i++) {        printf(" %d", post[i]);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-Invert-a-Binary-Tree"><a href="#4-Invert-a-Binary-Tree" class="headerlink" title="4.Invert a Binary Tree"></a>4.Invert a Binary Tree</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805365537882112">Invert a Binary Tree</a></p><p>题解：这个题给定了每个点的左右节点的值，然后求得其翻转二叉树的中序遍历和层序遍历，其实本质是一样的，翻转以后，我们中序遍历的顺序变成了右—中—左，层序遍历在每层的遍历顺序改为从右到左，所以我们在结构体的里面，添加了level和idx，代表了节点所在的层数和索引。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;#define ll long longconst int MAXN = 105;int isroot[MAXN];int n, root;// l,r代表左右节点，level代表层数，idx代表索引值struct node{    int id, l, r, level, idx;} tree[MAXN];// in,ceng代表中序，层序遍历vector&lt;node&gt; in, ceng;// 层序遍历，需要按照层数和索引值进行排序，需要cmp进行自定义排序bool cmp(node a, node b){    if (a.level != b.level)        return a.level &lt; b.level;    return a.idx &gt; b.idx;}// root是DFS对应的根节点，level，idx为层数和索引值void dfs(int root, int level, int idx){    if (tree[root].r != -1)    {        // 右边进行遍历，由于idx初始值为0，所以右孩子是idx * 2 + 2        dfs(tree[root].r, idx * 2 + 2, level + 1);    }    // 根节点进入数组    in.push_back({root, 0, 0, idx, level});    if (tree[root].l != -1)    {        // 左边进行遍历，由于idx初始值为0，所以右孩子是idx * 2 + 1        dfs(tree[root].l, idx * 2 + 1, level + 1);    }}int main(){    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    {        string lchild, rchild;        cin &gt;&gt; lchild &gt;&gt; rchild;        if (lchild == "-")        {            tree[i].l = -1;        }        else        {            // stoi函数，讲string转换为int            tree[i].l = stoi(lchild);            isroot[stoi(lchild)] = 1;        }        if (rchild == "-")        {            tree[i].r = -1;        }        else        {            tree[i].r = stoi(rchild);            isroot[stoi(rchild)] = 1;        }    }    // root是根节点    for (int i = 0; i &lt; n; i++)    {        if (!isroot[i])        {            root = i;            break;        }    }    dfs(root, 0, 0);    ceng = in;    // 自定义排序    sort(ceng.begin(), ceng.end(), cmp);    cout &lt;&lt; ceng[0].id;    for (int i = 1; i &lt; ceng.size(); i++)    {        cout &lt;&lt; " " &lt;&lt; ceng[i].id;    }    cout &lt;&lt; endl;    cout &lt;&lt; in[0].id;    for (int i = 1; i &lt; in.size(); i++)    {        cout &lt;&lt; " " &lt;&lt; in[i].id;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>今日份的总结就先到这里了啊，多多支持我的博客！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 算法 </tag>
            
            <tag> PAT甲级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora + picgo + gitee实现图床</title>
      <link href="/2021/08/19/configuration/article-1/"/>
      <url>/2021/08/19/configuration/article-1/</url>
      
        <content type="html"><![CDATA[<h2 id="gitee操作"><a href="#gitee操作" class="headerlink" title="gitee操作"></a>gitee操作</h2><p>登录gitee账号以后，点击新建仓库：</p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819225902.png" alt="image-20210819220159065"><p>仓库建好以后，我们点击设置，设置自己的个人token(也就是私人令牌)，新建以后，会自动生成了一段个人token的号码，一定要记清楚，后面配置的时候会需要。</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819220602.png" alt="image-20210819220601248"></p><h2 id="picgo操作"><a href="#picgo操作" class="headerlink" title="picgo操作"></a>picgo操作</h2><p> 官网下载地址：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p> 版本要求：2.2.0 及以上，我用的是2.2.2</p><p> 下载成功后，打开picgo，会出现如下的界面：</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819220934.png" alt="image-20210819220933193"></p><p>我们首先点击插件设置，搜索gitee，然后下载gitee-uploader插件，等待下载成功后，在图床设置里面会有对应的gitee选项。</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819221246.png" alt="image-20210819221244914"></p><p>这里的repo，我们可以打开刚才新建的仓库，然后查看地址栏，会发现对应的网址（<strong>记住去掉对应的码云域名才行</strong>）</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819221459.png" alt="image-20210819221457888"></p><h2 id="typora操作"><a href="#typora操作" class="headerlink" title="typora操作"></a>typora操作</h2><p>版本要求：0.9.84版本及以上</p><p>打开typora，点击文件 -&gt; 偏好设置，选择图像，上传服务选择PicGo(app)，路径选择picgo下载的路径。</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819224805.png" alt="image-20210819224549748"></p><p>然后，我们点击验证图片上传选项，进行最后的验证。如果返回true，说明图床配置成功！</p><p><img src="https://gitee.com/Fu--Kang/blog-img/raw/master/20210819224851.png" alt="image-20210819224849280"></p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>如果最后验证阶段的时候，程序运行结果返回的是false，那么可能会有以下情况：</p><ol><li>picgo配置的路径是否与仓库路径保持一致</li><li>确认下载的插件是否为gitee-uploader</li><li>在picgo设置里面，把时间戳重命名设置开</li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab基本语法</title>
      <link href="/2021/08/18/modeling/article-1/"/>
      <url>/2021/08/18/modeling/article-1/</url>
      
        <content type="html"><![CDATA[<h2 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h2><p>(1) 在每一行的语句后面加上分号(一定要是英文的哦;中文的长这个样子；)表示不显示运行结果</p><p>例如：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">% 表示不显示运行结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(2) 多行注释: 选中要注释的若干语句, 快捷键Ctrl+R</p><p>(3) 取消注释: 选中要取消注释的语句,快捷键Ctrl+T</p><p>(4) 用于起到初始化作用的代码语句：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">clear<span class="token punctuation">;</span>clc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h2><p>(1) disp函数</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'我是kangkang'</span><span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token function">disp</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(2) 字符串的合并(两种)</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token comment">% （1）strcat(str1,str2……,strn) </span><span class="token function">strcat</span><span class="token punctuation">(</span><span class="token string">'字符串1'</span><span class="token punctuation">,</span><span class="token string">'字符串2'</span><span class="token punctuation">)</span> <span class="token comment">% （2）[str 1,str 2，……, str n]或[str1  str2  ……  strn]</span><span class="token punctuation">[</span><span class="token string">'字符串1'</span>  <span class="token string">'字符串2'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>(3) 数字转化为字符串</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">c <span class="token operator">=</span> <span class="token number">100</span><span class="token function">num2str</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token function">disp</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'c的取值为'</span> <span class="token function">num2str</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(4) 输入函数</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token string">'请输入A：'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h2><p>（1）如果是向量（无论是行向量还是列向量），都是直接求和。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">E <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment">% 行向量</span><span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span>E <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment">% 列向量</span><span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（2）如果是矩阵，则需要根据行和列的方向作区分。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">E <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>a <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span>       <span class="token comment">%  默认按列求和(得到一个行向量）</span>a <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token comment">%  按列求和(得到一个行向量）</span>a <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>     <span class="token comment">%  按行求和(得到一个列向量）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（3）对整个矩阵进行求和</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span><span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token function">E</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="取矩阵元素"><a href="#取矩阵元素" class="headerlink" title="取矩阵元素"></a>取矩阵元素</h2><p>（1）取指定行和列的一个元素（输出的是一个值）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">1</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span> <span class="token number">1</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span> <span class="token number">3</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">% 取第二行第一列的元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（2）取指定的某一行 / 列 的全部元素（输出的是一个行向量）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>   <span class="token comment">% 取第二行的所有元素</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment">% 取第一列的所有元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（3）取指定的某些行的全部元素（输出的是一个矩阵）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>      <span class="token comment">% 只取第二行和第五行（一共2行）</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>        <span class="token comment">% 取第二行到第五行（一共4行）</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">:</span><span class="token keyword">end</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>      <span class="token comment">% 取第二行到最后一行</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span>      <span class="token comment">% 取第二行和第四行 （从2开始，每次递增2个单位，到5结束）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="size函数"><a href="#size函数" class="headerlink" title="size函数"></a>size函数</h2><p>（1）对于向量来说，返回的是元素的个数</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（2）size(A)函数是用来求矩阵A的大小的,它返回一个行向量，第一个元素是矩阵的行数，第二个元素是矩阵的列数</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>r <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">%  返回行数</span>c <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">%  返回列数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="repmat函数"><a href="#repmat函数" class="headerlink" title="repmat函数"></a>repmat函数</h2><p>B = repmat(A,m,n)： 将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>B <span class="token operator">=</span> <span class="token function">repmat</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>B <span class="token operator">=</span> <span class="token function">repmat</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h2><p>（1）MATLAB在矩阵的运算中， * 号和  / 号代表矩阵之间的乘法与除法(A / B = A * inv(B))</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>A <span class="token operator">*</span> B<span class="token function">inv</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>  <span class="token comment">% 求B的逆矩阵</span>B <span class="token operator">*</span> <span class="token function">inv</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>A <span class="token operator">*</span> <span class="token function">inv</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>A <span class="token operator">/</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）两个形状相同的矩阵对应元素之间的乘除法需要使用“ .* ”和“ ./ ”</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>A <span class="token operator">.*</span> BA <span class="token operator">./</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（3）每个元素同时和常数相乘或相除操作都可以使用</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>A <span class="token operator">*</span> <span class="token number">2</span>A <span class="token operator">.*</span> <span class="token number">2</span>A <span class="token operator">/</span> <span class="token number">2</span> A <span class="token operator">./</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）每个元素同时乘方时只能用 .^</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>A <span class="token operator">.^</span> <span class="token number">2</span>    <span class="token comment">% 表示对每个元素平方</span>A <span class="token operator">^</span> <span class="token number">2</span>     <span class="token comment">% 代表的是 A * A</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a>find函数</h2><p>find函数，它可以用来返回向量或者矩阵中不为0的元素的位置索引。</p><p>（1）对于向量来说，直接返回索引值。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">0</span> <span class="token number">4</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">8</span> <span class="token number">6</span><span class="token punctuation">]</span>ind <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>ind <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment">% 其有多种用法，比如返回前2个不为0的元素的位置：</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）对于矩阵来说，因为在Matlab在存储矩阵时，是一列一列存储的。所以我们要想返回行列值的话，需要：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token number">4</span> <span class="token number">0</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>Matlab的判断语句，if所在的行不需要冒号，语句的最后一定要以end结尾 ；中间的语句要注意缩进。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a <span class="token operator">=</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token string">'请输入考试分数:'</span><span class="token punctuation">)</span><span class="token keyword">if</span> a <span class="token operator">&gt;=</span> <span class="token number">85</span>      <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'成绩优秀'</span><span class="token punctuation">)</span><span class="token keyword">elseif</span> a <span class="token operator">&gt;=</span> <span class="token number">60</span>     <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'成绩合格'</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token string">'成绩挂科'</span><span class="token punctuation">)</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme主题介绍</title>
      <link href="/2021/08/18/hello-world/"/>
      <url>/2021/08/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>‌今天学习了hexo本地创建博客</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
